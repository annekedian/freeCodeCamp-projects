# -*- coding: utf-8 -*-
"""Neural Network SMS Text Classifier_Anneke.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L3Az2Mb9oLpSM7s0eoPXrDKtnkfKUqkd

# **Setup**
"""

import pandas as pd
!pip install tensorflow-datasets
import tensorflow_datasets as tfds
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.text import one_hot
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Flatten, Embedding, Dense, Bidirectional
from tensorflow.keras.callbacks import EarlyStopping

"""# **Setup input pipeline**"""

# get data files
!wget https://cdn.freecodecamp.org/project-data/sms/train-data.tsv
!wget https://cdn.freecodecamp.org/project-data/sms/valid-data.tsv

train_file_path = "train-data.tsv"
test_file_path = "valid-data.tsv"

train_dataset = pd.read_csv(train_file_path, sep='\t', names=["class", "messages"])
train_dataset.head(3)

test_dataset = pd.read_csv(test_file_path, sep='\t', names=["class", "messages"])
test_dataset.head(3)

#define x train, y train, x test, and y test
x_train = train_dataset.messages.values.tolist()
y_train = np.array([0 if x=="ham" else 1 for x in train_dataset['class'].values.tolist()])

x_test = test_dataset.messages.values.tolist()
y_test = np.array([0 if x=="ham" else 1 for x in test_dataset['class'].values.tolist()])

"""# **Create the text encoder**"""

vocabulary_dict = {}
for message in x_train:
  for vocabulary in message.split():
    if vocabulary not in vocabulary_dict:
      vocabulary_dict[vocabulary] = 1
    else:
      vocabulary_dict[vocabulary] += 1

vocab_size = len(vocabulary_dict)
max_length = len(max(x_train, key=lambda p: len(p.split())).split())

encoded_x_train = [one_hot(d, vocab_size) for d in x_train]
padded_x_train = pad_sequences(encoded_x_train, maxlen=max_length, padding='post')
encoded_x_test = [one_hot(d, vocab_size) for d in x_test]
padded_x_test = pad_sequences(encoded_x_test, maxlen=max_length, padding='post')

"""# **Create the model**"""

model = Sequential()
embedding_layer = Embedding(vocab_size, 100, input_length=max_length,mask_zero=True)
model.add(embedding_layer)
model.add(Dense(64, activation='relu'))
model.add(Flatten())
model.add(Dense(1, activation='sigmoid'))
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['acc'])
monitor = EarlyStopping(monitor='val_acc', min_delta=1e-4, patience=25, verbose=1, mode='max', restore_best_weights=True)
model.fit(padded_x_train, y_train, validation_data=(padded_x_test, y_test), callbacks=[monitor], epochs=10000, verbose=2)

"""# **Model evaluation**"""

# function to predict messages based on model
# (should return list containing prediction and label, ex. [0.008318834938108921, 'ham'])
def predict_message(pred_text):
  class_dict = {
      0 : "ham",
      1 : "spam",
      }
  encoded_message = [one_hot(pred_text, vocab_size)]
  padded_message = pad_sequences(encoded_message, maxlen=max_length, padding='post')
  prediction = [model.predict(padded_message)[0][0], class_dict[np.round(model.predict(padded_message)[0][0])]]
  return prediction

pred_text = "how are you doing today?"

prediction = predict_message(pred_text)
print(prediction)

# Run this cell to test your function and model. Do not modify contents.
def test_predictions():
  test_messages = ["how are you doing today",
                   "sale today! to stop texts call 98912460324",
                   "i dont want to go. can we try it a different day? available sat",
                   "our new mobile video service is live. just install on your phone to start watching.",
                   "you have won Â£1000 cash! call to claim your prize.",
                   "i'll bring it tomorrow. don't forget the milk.",
                   "wow, is your arm alright. that happened to me one time too"
                  ]

  test_answers = ["ham", "spam", "ham", "spam", "spam", "ham", "ham"]
  passed = True

  for msg, ans in zip(test_messages, test_answers):
    prediction = predict_message(msg)
    if prediction[1] != ans:
      passed = False

  if passed:
    print("You passed the challenge. Great job!")
  else:
    print("You haven't passed yet. Keep trying.")

test_predictions()

